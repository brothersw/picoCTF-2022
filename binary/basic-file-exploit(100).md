**Description**

Author: Will Hong

The program provided allows you to write to a file and read what you wrote from it. Try playing around with it and see if you can break it! Connect to the program with netcat: $ nc saturn.picoctf.net 52682 The program's source code with the flag redacted can be downloaded here.

Hints
1) Try passing in things the program doesn't expect. Like a string instead of a number.

**Analysis**

Lets look at the source given to us to theorize an exploit. First, we can look to where a flag is printed and can backtrack from there.
The function data_read() starting on line 126 is the only function that deals with printing the flag.

```C
static void data_read() {
  char entry[4];
  long entry_number;
  char output[100];
  int r;

  memset(output, '\0', 100);
  
  printf("Please enter the entry number of your data:\n");
  r = tgetinput(entry, 4);
  // Timeout on user input
  if(r == -3)
  {
    printf("Goodbye!\n");
    exit(0);
  }
  
  if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
  }

  entry_number--;
  strncpy(output, data[entry_number], input_lengths[entry_number]);
  puts(output);
}
```

It seems that our flag is protected behind the check:

```C
if ((entry_number = strtol(entry, NULL, 10)) == 0) {
```

Lets find out what strtol() does, we need to get this to return 0.
You can type ```man strtol``` to pull up the manual page on the funciton.
You can find this text:

```
The  strtol()  function converts the initial part of the string in nptr
       to a long integer value according to the given base, which must be  be‚Äê
       tween 2 and 36 inclusive, or be the special value 0.
```

It shows the strtol takes a string that contains an integer and transforms it into its number equivalent. It can accept other bases, and if it cannot do anything with the input, it reutrns 0.

So, we need to find wherever the ```entry``` variable is declared, and give it input that doesn't contain a number.
```C
int main(int argc, char** argv) {
  char input[3] = {'\0'};
  long command;
  int r;

  puts("Hi, welcome to my echo chamber!");
  puts("Type '1' to enter a phrase into our database");
  puts("Type '2' to echo a phrase in our database");
  puts("Type '3' to exit the program");

  while (true) {   
    r = tgetinput(input, 3);
    // Timeout on user input
    if(r == -3)
    {
      printf("Goodbye!\n");
      exit(0);
    }
    
    if ((command = strtol(input, NULL, 10)) == 0) {
      puts("Please put in a valid number");
    } else if (command == 1) {
      data_write();
      puts("Write successful, would you like to do anything else?");
    } else if (command == 2) {
      if (inputs == 0) {
        puts("No data yet");
        continue;
      }
      data_read();
      puts("Read successful, would you like to do anything else?");
    } else if (command == 3) {
      return 0;
    } else {
      puts("Please type either 1, 2 or 3");
      puts("Maybe breaking boundaries elsewhere will be helpful");
    }
  }

  return 0;
}
```

The ```data_read()``` function is called in ```main()``` under the condition that ```command == 2``` and that there is a valid input entry already in the system. This input entry is created with the ```data_write()``` command, which is run when ```command == 1```
In ```data_read()``` the input assigned from there is the variable we need to exploit.

**Exploit**

First, enter command 1 and follow the instructions until you get back into the command selection menu screen. This can be preformed as intended. 
Now, enter the command 2 to enter the ```data_read()``` file.

After ```Please enter the entry number of your data:``` is printed, enter your exploit of a character with a character that isn't a number.
I entered ```a```

This should then return our flag!
It was ```picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_038A9E95}```
